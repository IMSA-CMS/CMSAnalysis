#include "CIAnalysis/CIStudies/interface/ResolutionModule.hh"
#include "CIAnalysis/CIStudies/interface/MatchingModule.hh"

#include <TGraphErrors.h>
#include <vector>
#include <TF1.h>

ResolutionModule::ResolutionModule(const MatchingModule& matchingModule, int minMass, int maxMass, int massInterval) :
  matching(matchingModule),
  minMassCut(minMass),
  maxMassCut(maxMass),
  interval(massInterval)
{
}

bool ResolutionModule::process(const edm::EventBase& event)
{
  auto bestPairs = matching.getMatchingBestPairs();

  if (bestPairs.getSize() >= 2)
    {
      double genSimMass = bestPairs.getGenParticles().getInvariantMass();
      std::string massBin = pickMassBin(genSimMass);

      for (auto matchingPair : bestPairs.getPairs())
	{
	  fillHistogram("ResolutionHistBin" + massBin, matchingPair.getPtError());
	}
    }

  return true;
}

void ResolutionModule::initialize()
{
  auto numberOfBins = getNumberOfBins();


  for(int i = 0; i < numberOfBins; ++i)
    {
      const std::string resolutionStr = "Resolution";
      
      const int histBins = 100;
      
      const double minPtError = -0.5;
      const double maxPtError = 0.5;

      makeHistogram(("ResolutionHistBin" + std::to_string(i * interval + minMassCut)), resolutionStr, histBins, minPtError, maxPtError);
    }
}

void ResolutionModule::finalize()
{
  auto pTErrorMeanHist = makeTGraphErrors("pTErrorMeanHist", getNumberOfBins());
  auto pTErrorStdDevHist = makeTGraphErrors("pTErrorStdDevHist", getNumberOfBins());

  addObject("pTErrorMeanHist", pTErrorMeanHist);
  addObject("pTErrorStdDevHist", pTErrorStdDevHist);

  const int xError = interval / 2;

  int index = 0;
  int median = minMassCut + interval / 2;

  for (int i = minMassCut; i < maxMassCut; i += interval)
    {
      auto errorMean = getErrorValues(getHistogram("ResolutionHistBin" + std::to_string(i)), "mean");
      auto errorStdDev = getErrorValues(getHistogram("ResolutionHistBin" + std::to_string(i)), "standard deviation");

      pTErrorMeanHist->SetPoint(index, median, errorMean.first);
      pTErrorMeanHist->SetPointError(index, xError, errorMean.second);

      pTErrorStdDevHist->SetPoint(index, median, errorStdDev.first);
      pTErrorStdDevHist->SetPointError(index, xError, errorStdDev.second);

      ++index;
      median += interval;
    }

  AnalysisModule::finalize();
}

std::string ResolutionModule::pickMassBin(double invariantMass) const
{
  int mass = static_cast<int>(invariantMass) / interval * interval; //mass is invariantMass floored to the highest multiple of interval
  if (mass < minMassCut)
    {
      mass = minMassCut;
    }
  else if (mass > maxMassCut - interval)
    {
      mass = maxMassCut - interval;
    }

  return std::to_string(mass);
}

const int ResolutionModule::getNumberOfBins() const
{
  return (maxMassCut - minMassCut) / interval;
}

TGraphErrors* ResolutionModule::makeTGraphErrors(std::string name, int numberOfBins) const
{
  auto hist = new TGraphErrors(numberOfBins);
  hist->SetTitle(name.c_str());
  //addObject(name, hist);

  return hist;
}

std::pair<double, double> ResolutionModule::getErrorValues(TH1* histogram, std::string errorType)
{
  const double minPtError = -0.5;
  const double maxPtError = 0.5;
  histogram->Fit("gaus", "", "", minPtError, maxPtError);

  auto gaus = histogram->GetFunction("gaus");

  if (errorType == "mean")
    {
      std::pair<double, double> mean(gaus->GetParameter(1), gaus->GetParError(1));
      return mean;
    }

  else if (errorType == "standard deviation")
    {
      std::pair<double, double> stdDev(gaus->GetParameter(2), gaus->GetParError(2));
      return stdDev;
    }
  else 
    {
      throw std::runtime_error("Invalid Error Type");
    }
}

